
# discretemath_project
Проект з дискретної математики на тему "Знаходження максимального планарного підграфу"

Планарні графи є важливим об’єктом дослідження в теорії графів та знаходять застосування у проектуванні електронних схем, геометричному моделюванні та комп’ютерній графіці. Однією із задач, що постає при роботі з такими структурами, є виділення максимального планарного підграфа з довільного графа. У цій роботі розглянуто підходи до побудови такого підграфа та подано програмну реалізацію відповідного алгоритму. Звіт описує процес проєктування, реалізації та тестування цього алгоритму.

Розподіл роботи:

1)Інтерфейс, візуалізація  -> Сю Олексій

2)Читання графу і записування результату -> Якимчук Галина

3)Алгоритм -> Дмитрів Мар'ян

4)Перевірки на планарність -> Шимчук Соломія

5)Тести для алгоритму + додаткові функції -> Німас Ксенія

1. Зчитування графа
Зчитування графа відбувається за допомогою функції graph_input(), у
якій користувач має інтерактивно ввести граф. Вона використовує
формат списку ребер для введення та формує словник суміжності
для внутрішнього представлення графа.
● directed = False це параметр функції, який означає, що граф за
замовчуванням неорієнтований. Тобто, коли користувач
вводить ребро u v, то автоматично додається ребро v u. У
випадку, коли граф орієнтований (directed = True), то функція
додасть лише ребро u–>v.
● Опісля, ініціалізується словник суміжності adjacency_dict = {},
у якому ключі - це вершини, а значення - множини їхніх
сусідів. Після цього запускається цикл з проханням ввести
граф, який не припиниться доти, доки користувач не введе
“stop”.
● Після завершення циклу рядок розбивається на 2 дві частини
(u v), а далі відбувається спроба перетворення обох частин на
числові значення (int). Якщо користувач вирішив ініціалізувати
вершини не числовими значеннями, а символьними
(наприклад, ‘А’, ‘В’ тощо), то код це передбачає і залишить
значення у типі рядків.
● Наступний блок забезпечує коректне збереження зв'язків у
словнику. Якщо вершина u ще не існує як ключ у
adjacency_dict, вона ініціалізується з порожньою множиною
(set) сусідів. Використання множини гарантує, що одне й те
саме ребро не буде додано двічі. Сусід v додається до множини
сусідів u. Якщо граф неорієнтований (if not directed:),
виконується та сама логіка для зворотного зв'язку: v додається
як ключ (якщо потрібно), і u додається до множини сусідів v
● Після завершення циклу вводу, функція перетворює внутрішнє
подання графа. Генератор словника конвертує значення
кожного ключа-вершини з множини на список. Функція
повертає готовий словник суміжності.
3. Запис графа у новий файл
Запис графа відбувається за допомогою функції
write_graph_to_file_uv(), у яку функція отримує 3 параметри: filepath
куди записувати новий граф, сам graph, який переданий словником
суміжності та параметр directed, який відповідає за те, який граф
(орієнтований чи неорієнтований).
● Спочатку ініціалізуються змінні: список edges_to_write(), де
тимчасово будуть зберігатися ребра у форматі u v, які будуть
записані у файл, і множина seen_edges для відслідковування
того аби записати кожне фізичне ребро лише один раз.
● Після цього функція перебирає всі вершини та їх сусідів у
словнику суміжності. Якщо граф орієнтований, то кожне ребро
є унікальним, тому просто додаємо рядок "u v" до списку
запису, ігноруючи seen_edges. Для ідентифікації ребра, яке не
має напрямку, створюється канонічне представлення.
Наприклад, як для ребра 1-2, так і для ребра 2-1 канонічний
вигляд буде (1, 2) і після цього перевіряється, чи бачили ми вже
це канонічне ребро.
Якщо не бачили, воно додається до seen_edges, і лише тоді
його текстове представлення додається до edges_to_write.
Цей механізм гарантує, що ребро 1 2 буде записано у файл, але
коли цикл дійде до зворотного запису 2 1, він буде
проігнорований.
● Наприкінці здійснюється запис у новий файл
5. Візуалізація графа planar_graph_visual
Функція приймає планарний граф у вигляді словник, переробляє його на список, за допомогою бібліотеки networkx присвоює кожній вершині свою координату так, щоб у результаті виводивя саме планарний граф.
4. Ввід даних/Початок програми
Програма очікує введеня користувачем у командний рядок: 1 - назву файлу в якому міститься програма, 2 - тип даних що будуть передані, 3 - сама data. Консоль спромрожжна сприймати 3 типи даних: Файл з записом графу у вигляді 1 -> 2, 2 -> 4, 3 -> 1 type - 'file'; Матриця суміжності type - 'matrix'; Словник type - 'dict'. argparse зчитує консоль, парсить його на 2 аргументи, тип та дата, залежно від типу відбувається відповідне перетворення даних. В результаті незалежно від введеного типу даних, на виході програма видаватиме словник або булеве значення False, якщо при обробці даних виникла помилка. Якщо так сталось, то при введен в консолі команди '--help' перед користувачем відкриється мала інструкція з правильним способ введеня даних у командний рядок
5. Алгоритм
написано методом перебору ребер. Вхідний граф ми очищаємо від ребер і лишаємо тільки вершини, потім додаємо по одному ребру між точками, якщо воно було в заданому графі, і перевіряємо, чи граф залишився планарним. Якщо додавання ребра робить граф непланарним (перевищується умова Ейлера або з’являється підграф K₅ чи K₃,₃), то ребро відкидається. Таким чином, алгоритм жадібно будує максимальний планарний підграф, який містить якомога більше ребер з оригінального графа, але при цьому залишається планарним. Після побудови підграф виводиться у консоль, записується у файл і, за можливості, візуалізується через matplotlib.
