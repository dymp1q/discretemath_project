
# discretemath_project
Проект з дискретної математики на тему "Знаходження максимального планарного підграфу"

Планарні графи є важливим об’єктом дослідження в теорії графів та знаходять застосування у проектуванні електронних схем, геометричному моделюванні та комп’ютерній графіці. Однією із задач, що постає при роботі з такими структурами, є виділення максимального планарного підграфа з довільного графа. У цій роботі розглянуто підходи до побудови такого підграфа та подано програмну реалізацію відповідного алгоритму. Звіт описує процес проєктування, реалізації та тестування цього алгоритму.

Розподіл роботи:

1)Інтерфейс, візуалізація  -> Сю Олексій

2)Читання графу і записування результату -> Якимчук Галина

3)Алгоритм -> Дмитрів Мар'ян

4)Перевірки на планарність -> Шимчук Соломія

5)Тести для алгоритму + додаткові функції -> Німас Ксенія

1. Зчитування графа

Зчитування графа відбувається за допомогою функції graph_input(), у
якій користувач має інтерактивно ввести граф. Вона використовує
формат списку ребер для введення та формує словник суміжності
для внутрішнього представлення графа.
● directed = False це параметр функції, який означає, що граф за
замовчуванням неорієнтований. Тобто, коли користувач
вводить ребро u v, то автоматично додається ребро v u. У
випадку, коли граф орієнтований (directed = True), то функція
додасть лише ребро u–>v.
● Опісля, ініціалізується словник суміжності adjacency_dict = {},
у якому ключі - це вершини, а значення - множини їхніх
сусідів. Після цього запускається цикл з проханням ввести
граф, який не припиниться доти, доки користувач не введе
“stop”.
● Після завершення циклу рядок розбивається на 2 дві частини
(u v), а далі відбувається спроба перетворення обох частин на
числові значення (int). Якщо користувач вирішив ініціалізувати
вершини не числовими значеннями, а символьними
(наприклад, ‘А’, ‘В’ тощо), то код це передбачає і залишить
значення у типі рядків.
● Наступний блок забезпечує коректне збереження зв'язків у
словнику. Якщо вершина u ще не існує як ключ у
adjacency_dict, вона ініціалізується з порожньою множиною
(set) сусідів. Використання множини гарантує, що одне й те
саме ребро не буде додано двічі. Сусід v додається до множини
сусідів u. Якщо граф неорієнтований (if not directed:),
виконується та сама логіка для зворотного зв'язку: v додається
як ключ (якщо потрібно), і u додається до множини сусідів v
● Після завершення циклу вводу, функція перетворює внутрішнє
подання графа. Генератор словника конвертує значення
кожного ключа-вершини з множини на список. Функція
повертає готовий словник суміжності.

2. Запис графа у новий файл

Запис графа відбувається за допомогою функції
write_graph_to_file_uv(), у яку функція отримує 3 параметри: filepath
куди записувати новий граф, сам graph, який переданий словником
суміжності та параметр directed, який відповідає за те, який граф
(орієнтований чи неорієнтований).
● Спочатку ініціалізуються змінні: список edges_to_write(), де
тимчасово будуть зберігатися ребра у форматі u v, які будуть
записані у файл, і множина seen_edges для відслідковування
того аби записати кожне фізичне ребро лише один раз.
● Після цього функція перебирає всі вершини та їх сусідів у
словнику суміжності. Якщо граф орієнтований, то кожне ребро
є унікальним, тому просто додаємо рядок "u v" до списку
запису, ігноруючи seen_edges. Для ідентифікації ребра, яке не
має напрямку, створюється канонічне представлення.
Наприклад, як для ребра 1-2, так і для ребра 2-1 канонічний
вигляд буде (1, 2) і після цього перевіряється, чи бачили ми вже
це канонічне ребро.
Якщо не бачили, воно додається до seen_edges, і лише тоді
його текстове представлення додається до edges_to_write.
Цей механізм гарантує, що ребро 1 2 буде записано у файл, але
коли цикл дійде до зворотного запису 2 1, він буде
проігнорований.
● Наприкінці здійснюється запис у новий файл

3. Візуалізація графа planar_graph_visual

Функція приймає планарний граф у вигляді словник, переробляє його на список, за допомогою бібліотеки networkx присвоює кожній вершині свою координату так, щоб у результаті виводивя саме планарний граф.

4. Ввід даних/Початок програми

Програма очікує введеня користувачем у командний рядок: 1 - назву файлу в якому міститься програма, 2 - тип даних що будуть передані, 3 - сама data. Консоль спромрожжна сприймати 3 типи даних: Файл з записом графу у вигляді 1 -> 2, 2 -> 4, 3 -> 1 type - 'file'; Матриця суміжності type - 'matrix'; Словник type - 'dict'. argparse зчитує консоль, парсить його на 2 аргументи, тип та дата, залежно від типу відбувається відповідне перетворення даних. В результаті незалежно від введеного типу даних, на виході програма видаватиме словник або булеве значення False, якщо при обробці даних виникла помилка. Якщо так сталось, то при введен в консолі команди '--help' перед користувачем відкриється мала інструкція з правильним способ введеня даних у командний рядок

6. Алгоритм

Написаний методом перебору ребер. Вхідний граф ми очищаємо від ребер і лишаємо тільки вершини, потім додаємо по одному ребру між точками, якщо воно було в заданому графі, і перевіряємо, чи граф залишився планарним. Якщо додавання ребра робить граф непланарним (перевищується умова Ейлера або з’являється підграф K₅ чи K₃,₃), то ребро відкидається. Таким чином, алгоритм жадібно будує максимальний планарний підграф, який містить якомога більше ребер з оригінального графа, але при цьому залишається планарним. Після побудови підграф виводиться у консоль, записується у файл і, за можливості, візуалізується через matplotlib.

7. Тестування на планарність
   Функція отримує на ввід два типи даних: словник (у форматі списків суміжності) або
  список ребер графа. Після цього, залежно від типу введених даних, функція зчитує всі
  вершини та ребра, записує їх у множини (щоб усунути дублювання) та перетворює
  ребра до єдиного вигляду. Це забезпечує правильність подальших перевірок
  незалежно від того, у якому форматі дані були надані.
  Після зчитування структура графа перевіряється на планарність кількома способами:
  ● Перевірка за Ейлеровою межею.
Якщо кількість ребер графа перевищує значення 3V – 6 для V >= 3, граф
однозначно не є планарним. У такому випадку функція повертає False.
  ● Пошук підграфа K5.
Функція перебирає всі можливі набори з 5 вершин та перевіряє, чи утворюють
вони повний граф K5 (10 ребер між усіма парами вершин). Якщо такий граф
знайдений, повертається False.
  ● Пошук підграфа K3,3.
Для кожного набору з 6 вершин функція перевіряє всі можливі розбиття цих
вершин на дві частини по 3. Якщо між кожною вершиною першої частини та
кожною вершини другої існує ребро, підграф є K3,3, і функція також повертає
False.
Якщо граф проходить усі ці перевірки, функція повертає True, що говорить про те, що
граф може бути планарним.
Якщо користувач вводить дані неправильного формату — тобто щось інше, ніж список
або словник, — функція підіймає помилку TypeError та виводить відповідне
повідомлення для користувача.


7. Тестування алгоритму

Для оцінки працездатності розробленого алгоритму було підготовлено набір тестових графів різної структури та розміру. Метою такого підходу було перевірити коректність роботи алгоритму в різних умовах та забезпечити його стійкість до різноманітних типів вхідних даних. Частина графів була задана вручну або зчитана з файлів, а інша частина автоматично згенерована за допомогою спеціальних функцій. Усі тестові приклади умовно поділено на дві групи: планарні та непланарні графи.

Планарні приклади графів

- дерева (tree.txt)
- прості цикли (square.txt)
- граткові (grid) графи
  
Ґраткові графи генерувалися за допомогою функції generate_grid_to_file(rows, cols, filename) для різних розмірів(4*4, 6*6). Алгоритм цієї функції є таким, що граф будується як декартовий добуток двох шляхів:

Prows x Pcols

де rows — кількість рядків, а cols — кількість стовпців ґратки.
Кожна вершина відповідає певній клітинці прямокутної таблиці, а ребра з’єднують лише сусідні клітинки. Усі вершини нумеруються послідовно, починаючи з 0.
Вершині, що знаходиться в рядку r та стовпці c, ставиться у відповідність номер:

v = r * cols + c

Такий спосіб нумерації гарантує унікальність номерів вершин, спрощує обчислення сусідів та дозволяє легко масштабувати граф до великих розмірів.
Також для кожної вершини алгоритм перевіряє можливість створення ребер у двох напрямках: горизонтальні ребра у випадку, якщо вершина не знаходиться в останньому стовпці, вона з’єднується з вершиною праворуч та вертикальні ребра - якщо вершина не знаходиться в останньому рядку, то вона з’єднується з вершиною знизу. В кінці усі ребра записуються у файл у вигляді пар: u, v, де u та v — номери суміжних вершин.
Такі графи мають регулярну структуру та є класичними прикладами планарних графів. Вони дозволили оцінити роботу алгоритму при зростанні кількості вершин і ребер. 

Непланарні приклади графів 

- цикли з додатковими ребрами (хордами)
  
  Функція generate_cycle_with_random_chords(n, num_chords, filename) призначена для генерації графів спеціального типу, а саме циклів з додатковими випадковими ребрами (хордами). Такі графи використовуються
  для тестування алгоритму на структурах, які початково мають просту планарну форму, але можуть ускладнюватися шляхом додавання нових зв’язків. На першому етапі функція створює простий цикл C_n, який   складається з n вершин, пронумерованих від 0 до n−1. Кожна вершина i з’єднується з вершиною i + 1, а остання вершина n−1 — з вершиною 0. Таким чином формується замкнений ланцюг, у якому кожна вершина має ступінь 2. Отриманий граф: є зв’язним, планарним та має мінімальну кількість ребер для замкненої структури. Після побудови базового циклу функція переходить до додавання випадкових хорд — ребер, які з’єднують не суміжні вершини циклу. Процес додавання хорд відбувається ітеративно, поки загальна кількість ребер не досягне n + num_chords. При цьому для кожної потенційної хорди перевіряються такі умови: ребро виду (u, u) не допускається, не дозволяється повторно додавати ребра між сусідніми вершинами циклу та хорда не додається, якщо таке ребро вже існує в графі. Лише після виконання всіх перевірок ребро додається до множини.
- повні двочасткові графи (k3,3.txt)
- повні графи (k5.txt, k7.txt)
- випадкові графи (згенеровані програмно)
